CHAPTER 1:
1.rails command creates:
  rails new hello_app
2.Bundles:
	file: gemfile
	constructure: gem 'webpacker', '~> 4.0'
	command:
		bundle update
		bundle install
		bundle install --without production
3.run app:
	rails server
	default adress: http://localhost:3000
4.architectural pattern:
	MVC
5.Version control system:
	github
CHAPTER 2:
1. rails scaffold:
	rails generate scaffold User name:string email:string
2. migrate database:
	rails db:migrate
3. Create user by scaffold:
	rails generate scaffold User name:string email:string
	list pages for suser:
		/users index page to list all users
		/users/1 show page to show user with id 1
		/users/new new page to make a new user
		/users/1/edit edit page to edit user with id 1
4. restful routes provided by the user resources
	HTTP request URL Action Purpose
	GET /users index page to list all users
	GET /users/1 show page to show user with id 1
	GET /users/new new page to make a new user
	POST /users create create a new user
	GET /users/1/edit edit page to edit user with id 1
	PATCH /users/1 update update user with id 1
	DELETE /users/1 destroy delete user with id 1
	
	note
	GET: Được dử dụng để yêu cầu tài nguyên phía máy chủ	
	POST:được sử dụng để gửi dữ liệu đến máy chủ để xử lý. Nó thường được sử dụng để tạo mới một tài nguyên trên máy chủ
		(post sẽ không đưa dữ liệu lên url mà nó sẽ gửi dữ liệu bên trong phần thân của HTTP)
	PUT:để cập nhật hoặc thay đổi tài nguyên trên máy chủ 
	DELETE: được sử dụng để xóa một tài nguyên trên máy chủ
	PATCH: tương tự như PUT, được sử dụng để cập nhật thay đổi dữ liệu trên máy chủ . Nhưng nó chỉ cập nhật tài nguyên được chỉ định và không thay đổi các trường khác
5. By referring to Figure 2.11, write out the analogous steps for visiting the
URL /users/1/edit.
	-The browser issues a request for the /user/1/edit URL.
	-Rails routes /user/1/edit to the edit action in Users controler with user_id=1
	-the edit action call set_user method,set_user asks the the user model to retrive information of user 1
	-the user model pulls user 1 from database.
	-the User model returns user 1 to the controller
	-the controller captures the user has user_id=1 in the @user variable
	,which is passed to the view the view uses embedded ruby to render the page as html
	-the controller passes the html back to the browser.
6. Weaknesses of scaffold Users resource:
	-No data validation
	-No authentication
	-No tests
	-No style or layout
	-No real understanding
7. associations between different data models
	-has_many
	-belong_to
8.Validate
	-validate :attribute, length: {maximum: 140}, presence:true
	-length {maximum: 140} max length of attribute
	-presence: cant blank
9.What we learned in this chapter
	• Scaffolding automatically creates code to model data and interact with it
	through the web.
	• Scaffolding is good for getting started quickly but is bad for understanding.
	• Rails uses the Model-View-Controller (MVC) pattern for structuring web
	applications.
	• As interpreted by Rails, the REST architecture includes a standard set of
	URLs and controller actions for interacting with data models.
	• Rails supports data validations to place constraints on the values of data
	model attributes.
	• Rails comes with built-in functions for defining associations between different data models.
	• We can interact with Rails applications at the command line using the
	Rails console.
CHAPTER 3
1.rails command shortcut
	#gengerated controller StaicPages with action help home
	$ rails generate controller StaticPages home help
	#remove controller StaticPages with action help home
	$ rails destroy controller StaticPages home help
	#create a Model User vs properties name email
	$ rails generate model User name:string email:string
	#remove a model User
	$ rails destroy model User
	#update version database newest 
	$ rails db:migrate
	#
	$ rails db:rollback
	#
	$ rails db:migrate VERSION=0
	
	$ rails server 			$ rails s
	$ rails console 		$ rails c
	$ rails generate 		$ rails g
	$ rails test 				$ rails t
	$ bundle install 		$ bundle
2.undo in Rails
	$ rails generate controller StaticPages home help			$ rails destroy controller StaticPages home help
	$ rails generate model User name:string email:string  $ rails destroy model User
	$ rails db:migrate			$ rails db:rollback			$ rails db:migrate VERSION=0
3.router
	#: controller
	/: url
CHAPTER 4:
CHAPTER 5:
CHAPTER 6:
	validate email :
	mã hóa mật khẩu :
	vòng đời của callback:
CHAPTER 7:
	$rails console : cho phép mở 1 irb console để tương tác với ứng dụng rails
	$rails console -e test : cho phép mở 1 console để tương tác với môi trường thử nghiệm
	$rails server --environment production : chạy rails serve trên môi trường sản phẩm
	$ rails db:migrate RAILS_ENV=production : 
	param: là 1 phần của request khi 1 request gửi từ client đến server sẽ mang theo param (param có thể chứa các thông tin gửi lên url...)và action được gọi đến có thể truy xuất data của param
	# hiển thị lỗi trên website
	.errors.full_messages : hiển thị ra mảng các lỗi
	.errors.count : hiển thị số lỗi
	.errors.empty? : kiểm tra xem lỗi có trống hay không
	.errors.any? kiểm tra xem có lỗi nào xuất hiện hay không ? nếu trả về true thì xuất hiện ít nhất 1 lối , nếu trả về false thì không có lỗi nào xuất hiện
	#
	rails db:migrate:reset database => migrate running form scartch
	#
CHAPTER 8:
	+ khai báo một session :
	session[:attribute] = value
	+ Truy cập vào một session
	vd user_id = session[:user_id]
	# sự khác nhau giữa find và find_by
		- find by : cho phép bạn tìm kiếm tới một bản ghi trong cơ sở dữ liệu dựa trên một điều kiện nhất định .Nó trả về bản ghi đầu tiên trong cơ sở dữ liệu mà thỏa mã điều kiện .Nó sẽ trả về bản ghi đầu tiên trong cơ sở dữ liệu thỏa mãn điều kiện , hoặc trả về nil nếu không có điều kiện nào tìm thấy
		- find : sẽ bắn ra một exception nếu không có bất kì record nào được tìm thấy ==> nó là nguyên nhân dẫn tới việc server bị cash
	# sự khác nhau giữa form_with vs form_tag vs form_for
	
	#authenticate_token : được tạo ra khi thực hiện các phương thức http post put patch delete khi gửi một yêu cầu http bằng phương thức này rails sẽ tạo ra một authenticate token và gắn vào yêu cầu đó. token này là một chuỗi ngẫu nhiên được tạo ra để đảm bảo tính xác thực  và bảo vệ ứng dụng khỏi các cuộc tấn công

CHAPTER 9:
	#thực hiện chức năng lưu đăng nhập bằng cách sử dụng cookies
	+ trong model/users tạo ra các method : 
	   - Tạo 1 biến : remember_token
	   - User.new_token : trả về một token ngẫu nhiên
	   - remember : ghi nhớ người dùng trong cơ sở dữ liệu bằng cách:
	   	+ tạo ra một mã token bằng cách gọi method User.new_token
	   	+ update cột :remember_digest bằng giá trị của token mới được tạo ra
	   - authenticated?(remember_token) : dùng để kiểm tra xem chuỗi token được gửi từ client có khớp với giá trị của cột remember_digest đã được lưu trong database không
	   - forget : sẽ hủy đi trạng thái đăng nhập của người dùng bằng cách cập nhật cột remember_digest về giá trị nil
	 + trong helper/sesions_helper:
	   - remember(user): có 2 bước 
	   	+ gọi tới user.remember để tạo một token và lưu giá trị vào cột remember_digest
	   	+ tạo ra 2 cookies :user_id, :remember_token : 
	   	  - user_id : tạo ra một cookie với thời gian sống lên đến 20 năm và mã hóa used_id đó
	   	  - remember_token: truy cập vào giá trị của biến remember_token của User
	  - current_user: phương thức này sẽ kiểm tra session trước rồi mới tới cookies
	  	+ đầu tiên sẽ kiểm tra id người dùng xem đã lưu trong session chưa nếu có ==> trả về người dùng đó
	  	+ kiểm tra cookies xem user_id đã được lưu trong cookie chưa .Nếu có sé tìm ra người dùng có id tương ứng và kiểm tra xem rember_token xem có khớp với remember_digest trong cơ sở dữ liệu không.nếu cookie hợp lệ sẽ đăng nhập bằng phương thức login và gán người dung cho biến @current_user.
	  - forget(user) : xóa user người dùng ==> cập nhật lại côt remember_digest bằng  nil , xóa cookie :user_id , :remember_token
CHAPTER 10: Cập nhật hiển thị và xóa người dùng
	#cập nhật người dùng
	#phân quyền bắt người dùng phải đăng nhập trước khi làm các việc sửa, xóa
	1.
	  before_action :logged_in_user, only: [:edit, :update] : 1 phương thức để kiểm tra xem người dùng đã đăng nhập khi thực hiện hành động sửa chưa
	  logged_in_user sẽ kiểm tra xem nguời dùng đã đăng nhập chưa nếu chưa đăng nhập thì bắt phải đăng nhập rồi mới cho sửa thông tin
	2.
	kiểm tra xem người đang sửa có phải sửa thông tin của mình không, tránh việc một nguời sửa thông tin của người khác
	- nếu đúng người dùng đang đăng nhập thì mới cho sửa 
	- nếu không đúng người dùng thì sẽ không cho sửa mà đưa về trang chủ
	3.
	hiển thị tất cả người dùng
	# phân trang 
	gem 'facker' dùng để tạo dữ liệu giả lập  --> clone 1 list dữ liệu phục vụ cho việc phân trang
	gem 'will_paginate', gem 'bootstrap-will_paginate' là 2 thư viện phục vụ cho việc phân trang trong rails
	@users = User.paginate(page: params[:page]) mặc định sẽ lấy 30 sản phẩm trên 1 trang ,và nếu muốn chỉ định số sản phẩm trên 1 trang thì làm như ví dụ
	vd 10 sản phẩm trên 1 trang @products = Product.all.paginate(page: params[:page], per_page: 10)
	4.
	# Xóa người dùng
CHAPTER 11: Kích hoạt người dùng
	# kích hoạt tài khoản bằng cách gửi email
	# làm chức năng quên mật khẩu

	  
	  
	 
	
